#!/bin/bash
                                                                                                                                                          
#  ad88888ba                                        88                          88888888ba                                                                  
# d8"     "8b                                       ""                          88      "8b                                                                 
# Y8,                                                                           88      ,8P                                                                 
# `Y8aaaaa,     ,adPPYba,  8b,dPPYba,  8b       d8  88   ,adPPYba,   ,adPPYba,  88aaaaaa8P'  88       88  8b,dPPYba,   8b,dPPYba,    ,adPPYba,  8b,dPPYba,  
#   `"""""8b,  a8P_____88  88P'   "Y8  `8b     d8'  88  a8"     ""  a8P_____88  88""""88'    88       88  88P'   `"8a  88P'   `"8a  a8P_____88  88P'   "Y8  
#         `8b  8PP"""""""  88           `8b   d8'   88  8b          8PP"""""""  88    `8b    88       88  88       88  88       88  8PP"""""""  88          
# Y8a     a8P  "8b,   ,aa  88            `8b,d8'    88  "8a,   ,aa  "8b,   ,aa  88     `8b   "8a,   ,a88  88       88  88       88  "8b,   ,aa  88          
#  "Y88888P"    `"Ybbd8"'  88              "8"      88   `"Ybbd8"'   `"Ybbd8"'  88      `8b   `"YbbdP'Y8  88       88  88       88   `"Ybbd8"'  88          



#------------------------------------------------------------------------------------
# Initialisation of globals.

set -o nounset
MYDIR=$( dirname "$(readlink -f "$0")" )
source "$MYDIR/_variables"
e=$(printf "\e") 
readonly CODE_S="$e[32m"
readonly CODE_E="$e[0m"

#------------------------------------------------------------------------------------
# die MSG [EXITCODE] - show the message (red) and exit exitcode.

function die { 
   echo " ">&2 ; echo -e "\e[31m\e[1m${1}\e[0m">&2  ; echo " ">&2
   EXITCODE=${2:-1}
   exit "$EXITCODE"
}

#------------------------------------------------------------------------------------
# showhelp - give some info about the service. SERVICENAME and IMAGENAME are provided by _variables.

function showhelp {
cat <<EOF >&2

NAME
   ${SERVICENAME} - Runs minecraft
       
SYNOPSIS
   ${SERVICENAME} help            - This help
   ${SERVICENAME} configure PORT  - Configure for port PORT
   ${SERVICENAME} start           - Make it go!
   ${SERVICENAME} stop            - Stop it
   ${SERVICENAME} status          - Is it running?
   
DESCRIPTION
   Built from ${IMAGENAME}.
   
EOF
}

#------------------------------------------------------------------------------------
# Run a command in the container. 

function dockerrun {
   local RVAL=0
   docker run "${COMMANDOPTS[@]}" --name="${SERVICENAME}-${COMMAND}" -h "${HOSTNAME}" "${DOCKEROPTS[@]}" "${IMAGENAME}" "$@"
   RVAL=$?
   docker rm "${SERVICENAME}-${COMMAND}" >/dev/null
   [ $RVAL -eq 0 ] || die "${SERVICENAME} ${COMMAND} failed."
}

#------------------------------------------------------------------------------------
# See if a container is exists. Return value of docker inspect is correct (0 if running)
# https://gist.github.com/ekristen/11254304

function container_exists {
   # exit code of docker inspect says if it's running.
   docker inspect --format="{{ .State.Running }}" "$1" >/dev/null 2>&1
}

#------------------------------------------------------------------------------------
# See if a container is running

function container_running {
   container_exists "$1" || return 1
   local RUNNING=$(docker inspect --format="{{ .State.Running }}" "$1" 2>/dev/null)
   [ "${RUNNING}" = "true" ]
}

#------------------------------------------------------------------------------------
# Get the port from the configuration file.

function getPort {
   PORT=$(docker run -i --name="${SERVICENAME}-getport" ${DOCKEROPTS[@]} ${IMAGENAME} bash -c "cat /config/port")
   RVAL=$?
   docker rm "${SERVICENAME}-getport" >/dev/null 2>&1
   [ "$RVAL" -eq 0 ] || die "Failed to get port. Please run configure first."
   [ -n "$PORT" ] || die "Run configure first!"
}

#------------------------------------------------------------------------------------
# Determine the host ip. See http://stackoverflow.com/a/25851186

function getHostIP {
   HOSTIP=$(ip route get 1 | awk '{print $NF;exit}')
}

#------------------------------------------------------------------------------------
# Display the status of hte service.

function showStatus {
   container_exists "${SERVICENAME}-run"  || { echo "${SERVICENAME}'s container does not exist." ; exit 0 ; }
   container_running "${SERVICENAME}-run" || { echo "${SERVICENAME}'s container is stopped." ; exit 0 ; }
   getPort
   getHostIP
   echo "Minecraft is running on ${HOSTIP}:${PORT}"   
}

#------------------------------------------------------------------------------------
# Stop the service if it's running. TODO: Exit 3 on no change.

function stop {
   ! container_running "${SERVICENAME}-run" || docker stop --time=30 "${SERVICENAME}-run" >/dev/null 2>&1
   ! container_exists "${SERVICENAME}-run"  || docker rm "${SERVICENAME}-run" >/dev/null 2>&1
   showStatus   
}

#------------------------------------------------------------------------------------
# Start the service if it's not running. Exits 3 on no change.

function start {
   ! container_running "${SERVICENAME}-run" || die "Already running" 3 
   ! container_exists "${SERVICENAME}-run"  || docker rm "${SERVICENAME}-run" >/dev/null 2>&1

   getPort

   # Run the service. 
   # DOCKEROPTS, SERVICENAME AND IMAGENAME are set by _variables.
   COMMANDOPTS=("-d" "-p=${PORT}:25565" "-p=${PORT}:25565/udp" "--restart=always")
   dockerrun java -jar /minecraft_server.1.8.7.jar                          
   [ $? -eq 0 ] || die "Failed to launch minecraft on port $PORT :("
   showStatus
}

#------------------------------------------------------------------------------------
# The main function. We can add any commands we'd like here!

function main {
   [ "$#" -gt 0 ] || die "servicerunner must have the install argument."

   COMMAND="${1}" ; shift
   
   case "$COMMAND" in 
         install)
            ;;
            
         destroy)
            ;;
                     
         backup)
            # data volume is automatically hot backed up. We are paranoid here, taking a paused
            # backup as well. Probably don't need this for minecraft, but good as an example.
            # This does mean the backup set contains both hot + paused backups, doubling the data
            # size. Could avoid this by managing the data container ourselves (not listing it in
            # service.cfg), but minecraft data is small so we don't care.
            BACKUPPATH="$1"
            STARTED=1
            container_running "${SERVICENAME}-run" && STARTED=0 && docker pause "${SERVICENAME}-run"
            COMMANDOPTS=("-i" "-v" "${BACKUPPATH}:/backups")
            dockerrun bash -c 'tar zcf /backups/databackup.tgz /data'
            [ -e "${BACKUPPATH}/databackup.tgz" ] || die "Failed to create cold backup of minecraft data volume."
            [ STARTED -eq 1 ] || docker unpause "${SERVICENAME}-run" 
            ;;
         
         restore)
            # cold restore.
            RESTOREPATH="$1"
            ! container_running "${SERVICENAME}-run" || die "Can't restore into a running container!"
            [ -e "${RESTOREPATH}/databackup.tgz" ] || { ls "${RESTOREPATH}" ; die "Restore path does not contain the data volume backup." }
            COMMANDOPTS=("-i" "-v" "${RESTOREPATH}:/backups")
            # could compare hot + paused backups if we wanted here. We just throw away the hot one.
            dockerrun bash -c 'rm -r /data/* && tar zxf /backups/databackup.tgz'
            ;;
         
         help)
            showhelp
            ;;
         
         enter)
            dockerrun /bin/bash "$@"
            ;;
         
         update)
            ;;

         start)
            start
            ;;
         
         configure)
            ! container_running "${SERVICENAME}-run" || die "Can't configure while ${SERVICENAME} is started. Stop it first."
            [ "$#" -eq 1 ] || { showhelp ; die "You need to specify the PORT."; }
            PORT="$1"
            
            COMMANDOPTS=("-i")
            dockerrun bash -c "echo -n $PORT > /config/port && echo eula=true > /data/eula.txt"
            ;;

         stop)
            # check if running, if so stop it.
            stop
            ;;
         
         status)
            showStatus
            ;;
            
         *)
            showhelp
            die "Unrecognised command ${CODE_S}${COMMAND}${CODE_E}"            
            ;;
   esac
}

#------------------------------------------------------------------------------------

main "$@"
